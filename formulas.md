# Markdown Test #4



<img src="https://render.githubusercontent.com/render/math?math=(a_1 + a_2)^2 = a_1^2 + 2a_1a_2 + a_2^2">

Simple examples:

<img src="https://render.githubusercontent.com/render/math?math=(a_1 + a_2)^2 = a_1^2 + 2a_1a_2">


<img src="https://render.githubusercontent.com/render/math?math=(a_1 + a_2)^2 = a_1^2 + 2a_1a_2 + a_2^2">


<img src="https://render.githubusercontent.com/render/math?math=\dot{x} = \sigma(y-x) \\\dot{y} = \rho x - y - xz \\\dot{z} = -\beta z + xy">


<img src="https://render.githubusercontent.com/render/math?math=\begin{eqalign}
\nabla \cdot \vec{\bf E} & = \frac {\rho} {\varepsilon_0} \\
\nabla \cdot \vec{\bf B} & = 0 \\
\nabla \times \vec{\bf E} &= - \frac{\partial\vec{\bf B}}{\partial t} \\
\nabla \times \vec{\bf B} & = \mu_0\vec{\bf J} + \mu_0\varepsilon_0 \frac{\partial\vec{\bf E}}{\partial t}
\end{eqalign}
">


<img src="https://render.githubusercontent.com/render/math?math=(a_1 + a_2)^2 = a_1^2 + 2a_1a_2 + a_2^2 (a_1 + a_2)^2 = a_1^2 + 2a_1a_2 + a_2^2 (a_1 + a_2)^2 = a_1^2 + 2a_1a_2 + a_2^2">


<img src="https://render.githubusercontent.com/render/math?math=\begin{gather}
\dot{x} = \sigma(y-x) \\
\dot{y} = \rho x - y - xz \\
\dot{z} = -\beta z + xy
\end{gather}">

Use the *gather* or *display-lines* environments to center multiple equations:

Cross product:

<img src="https://render.githubusercontent.com/render/math?math=\vec \bf V_1 \times \vec \bf V_2 =  \begin{vmatrix}
\hat \imath &\hat \jmath &\hat k \\
\frac{\partial X}{\partial u} & \frac{\partial Y}{\partial u} & 0 \\
\frac{\partial X}{\partial v} & \frac{\partial Y}{\partial v} & 0
\end{vmatrix}

\vec \bf V_1 \times \vec \bf V_2 =  \begin{vmatrix}
\hat \imath &\hat \jmath &\hat k \\
\frac{\partial X}{\partial u} & \frac{\partial Y}{\partial u} & 0 \\
\frac{\partial X}{\partial v} & \frac{\partial Y}{\partial v} & 0
\end{vmatrix}

\vec \bf V_1 \times \vec \bf V_2 =  \begin{vmatrix}
\hat \imath &\hat \jmath &\hat k \\
\frac{\partial X}{\partial u} & \frac{\partial Y}{\partial u} & 0 \\
\frac{\partial X}{\partial v} & \frac{\partial Y}{\partial v} & 0
\end{vmatrix}
















">

Use the *aligned*, *eqalign* or *split* environments to align multiple equations:


Supported matrix environments: *matrix*, *pmatrix*, *bmatrix*, *Bmatrix*, *vmatrix*, *Vmatrix**:*

<img src="https://render.githubusercontent.com/render/math?math=\begin{pmatrix}
a & b\\ c & d
\end{pmatrix}
\begin{pmatrix}
\alpha & \beta \\ \gamma & \delta
\end{pmatrix} =
\begin{pmatrix}
a\alpha + b\gamma & a\beta + b \delta \\
c\alpha + d\gamma & c\beta + d \delta 
\end{pmatrix}











">



Cases:

<img src="https://render.githubusercontent.com/render/math?math=f(x) = \begin{cases}
\frac{e^x}{2} & x \geq 0 \\
1 & x < 0
\end{cases}">



Splitting long equations:

<img src="https://render.githubusercontent.com/render/math?math=\frak Q(\lambda,\hat{\lambda}) =
-\frac{1}{2} \mathbb P(O \mid \lambda ) \sum_s \sum_m \sum_t \\\gamma_m^{(s)} (t) +
\quad \left( \log(2 \pi ) + \log \left| \cal C_m^{(s)} \right| +
\left( o_t - \hat{\mu}_m^{(s)} \right) ^T \cal C_m^{(s)-1} \right) ">



Very long formula

<img src="https://render.githubusercontent.com/render/math?math=Craft = \sqrt{\frac{1}{N}\sum_{i=1}^N (x_i - \mu)^2}">


<img src="https://render.githubusercontent.com/render/math?math=i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\

i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\

i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\

i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\

i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\

i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\

i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\

i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\

i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\

i\hbar\frac{\partial}{\partial t}\mathbf\Psi(\mathbf{x},t) =
 -\frac{\hbar}{2m}\nabla^2\mathbf\Psi(\mathbf{x},t)
+ V(\mathbf{x})\mathbf\Psi(\mathbf{x},t) \\">



Code test:
```
// go
ctx.saveGState()
                ctx.textMatrix = .identity
                ctx.translateBy(x: targetX, y: targetY)
                ctx.scaleBy(x: 1, y: -1)
                d.draw(ctx)
                // Pop the previous state so we don’t have to inverse transform and this will be a very long comment..
                ctx.restoreGState()
ctx.textMatrix = .identity
				ctx.translateBy(x: targetX, y: targetY)
				ctx.scaleBy(x: 1, y: -1)
				d.draw(ctx)
				// Pop the previous state so we don’t have to inverse transform and this will be a very long comment..
				ctx.restoreGState()
ctx.textMatrix = .identity
				ctx.translateBy(x: targetX, y: targetY)
				ctx.scaleBy(x: 1, y: -1)
				d.draw(ctx)
				// Pop the previous state so we don’t have to inverse transform and this will be a very long comment..
				ctx.restoreGState()
ctx.textMatrix = .identity
				ctx.translateBy(x: targetX, y: targetY)
				ctx.scaleBy(x: 1, y: -1)
				d.draw(ctx)
				// Pop the previous state so we don’t have to inverse transform and this will be a very long comment..
				ctx.restoreGState()
```
